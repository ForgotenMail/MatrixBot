import os
import sys
import time
import sqlite3
import csv
from collections import defaultdict
from datetime import datetime

from authlib.jose import jwt
import simplematrixbotlib as botlib

import requests
from datetime import datetime
import os

# === CONFIGURATION ===
CLOUDREVE_WEBDAV_URL = "https://files.gleipnir.technology/dav/"  # WebDAV root
CSV_FILE_PATH = "output/logs.csv"  # Local path to your CSV file

# Your Cloudreve credentials
CLOUDREVE_USERNAME = "your_username_here"
CLOUDREVE_PASSWORD = "your_password_here"

# Generate a unique name for each uploaded file (or just "logs.csv" to overwrite)
timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
remote_filename = f"logs_{timestamp}.csv"

# Full URL for upload
upload_url = os.path.join(CLOUDREVE_WEBDAV_URL, remote_filename)

# Upload the file via WebDAV (using HTTP Basic Auth)
with open(CSV_FILE_PATH, "rb") as f:
    response = requests.put(
        upload_url,
        auth=(CLOUDREVE_USERNAME, CLOUDREVE_PASSWORD),
        data=f
    )

# Check the response
if response.status_code in [200, 201, 204]:
    print(f"‚úÖ Upload successful: {remote_filename}")
else:
    print(f"‚ùå Upload failed ({response.status_code}): {response.text}")


PREFIX = "!"

# === Globals for time tracking ===
StartTime = 0
ElapsedTime = 0
memo_text = ""

# === Base folder for database and CSV export ===
BASE_DIR = r"C:\Users\willi\Documents\MatrixBot"
DB_PATH = os.path.join(BASE_DIR, "worklogs.db")

# === Ensure base folder exists ===
os.makedirs(BASE_DIR, exist_ok=True)

# === Set up the SQLite database ===
conn = sqlite3.connect(DB_PATH)
cursor = conn.cursor()
cursor.execute('''
    CREATE TABLE IF NOT EXISTS logs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user TEXT NOT NULL,
        date TEXT NOT NULL,
        hours REAL NOT NULL,
        memo TEXT NOT NULL
    )
''')
conn.commit()


def insert_log(user, hours, memo):
    date = datetime.now().strftime("%Y-%m-%d")
    cursor.execute("INSERT INTO logs (user, date, hours, memo) VALUES (?, ?, ?, ?)",
                   (user, date, hours, memo))
    conn.commit()
    export_aggregated_csv()  # Export CSV after every insert


def export_aggregated_csv():
    cursor.execute("SELECT user, date, hours, memo FROM logs ORDER BY user, date")
    rows = cursor.fetchall()

    # Aggregate logs by (user, date)
    aggregate = defaultdict(lambda: {"hours": 0, "memo": ""})

    for user, date, hours, memo in rows:
        aggregate[(user, date)]["hours"] += hours
        if memo.strip():
            if aggregate[(user, date)]["memo"]:
                aggregate[(user, date)]["memo"] += "\n" + memo.strip()
            else:
                aggregate[(user, date)]["memo"] = memo.strip()

    csv_path = os.path.join(BASE_DIR, "worklogs_export.csv")
    with open(csv_path, "w", newline="", encoding="utf-8") as csvfile:
        fieldnames = ["User", "Date", "Hours", "Memo"]
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        for (user, date), data in aggregate.items():
            writer.writerow({
                "User": user,
                "Date": date,
                "Hours": round(data["hours"], 4),
                "Memo": data["memo"]
            })


def get_token() -> str:
    token = os.environ.get("BOT_TOKEN")
    if token is None:
        try:
            with open("token.txt", "r") as f:
                token = f.read().strip()
                return token
        except OSError as e:
            print(f"Failed to read token: {e}")
        print("You must supply a BOT_TOKEN via environment variable or via token.txt")
        sys.exit(1)
    return token


def main() -> None:
    global StartTime, ElapsedTime, memo_text

    token = get_token()
    print(f"Token: {token}")
    creds = botlib.Creds(
        homeserver="https://matrix.gleipnir.technology",
        username="timecarder",
        access_token=token,
        session_stored_file="session.txt",
    )

    bot = botlib.Bot(creds)

    @bot.listener.on_message_event
    async def command_handler(room, message):
        global StartTime, ElapsedTime, memo_text

        match = botlib.MessageMatch(room, message, bot, PREFIX)
        sender = message.sender

        if not match.is_not_from_this_bot() or not match.prefix():
            return

        if match.command("START"):
            StartTime = time.time()
            ElapsedTime = 0
            await bot.api.send_text_message(room.room_id, "üü¢ Timer started. Don't mess it up.")

        elif match.command("PAUSE"):
            if StartTime == 0:
                await bot.api.send_text_message(room.room_id, "üò§ You need to START before you PAUSE.")
                return
            ElapsedTime += time.time() - StartTime
            StartTime = 0
            await bot.api.send_text_message(room.room_id, f"‚è∏Ô∏è Paused at {ElapsedTime:.2f} seconds.")

        elif match.command("UNPAUSE"):
            if StartTime != 0:
                await bot.api.send_text_message(room.room_id, "üò¨ It's already running, genius.")
                return
            StartTime = time.time()
            await bot.api.send_text_message(room.room_id, f"‚ñ∂Ô∏è Resumed. Keep going.")

        elif match.command("STOP"):
            if StartTime != 0:
                ElapsedTime += time.time() - StartTime
                StartTime = 0
            hours = ElapsedTime / 3600
            insert_log(sender, hours, memo_text.strip())
            await bot.api.send_text_message(room.room_id, f"‚èπÔ∏è Logged {hours:.2f} hours. Well done?")
            ElapsedTime = 0
            memo_text = ""

        elif match.command("MEMO"):
            new_memo = " ".join(match.args()).strip()
            if new_memo:
                timestamp = datetime.now().strftime("[%Y-%m-%d %H:%M:%S]")
                memo_text += f"{timestamp} {new_memo}\n"
                await bot.api.send_text_message(room.room_id, "üìù Memo added. You're a poet now.")
            else:
                await bot.api.send_text_message(room.room_id, "üòê That was... empty. Try again with actual words.")

        elif match.command("VIEW"):
            if any(name in sender for name in ["@williamribble:gleipnir.technology", "Eli"]):
                cursor.execute("SELECT user, date, hours, memo FROM logs ORDER BY user, date")
                rows = cursor.fetchall()
                if not rows:
                    await bot.api.send_text_message(room.room_id, "No logs to show. Work harder, slackers.")
                    return

                # Format output as a simple text table (not too big)
                text = "üóÇÔ∏è **All Worklogs:**\n\n"
                current_user = None
                for user, date, hours, memo in rows:
                    if user != current_user:
                        text += f"\nüë§ {user}\n"
                        current_user = user
                    text += f"  üìÖ {date}: {hours:.2f}h\n"
                    text += f"    üìù {memo.replace(chr(10), chr(10)+'    ')}\n"
                if len(text) < 4000:
                    await bot.api.send_text_message(room.room_id, text)
                else:
                    parts = [text[i:i + 3900] for i in range(0, len(text), 3900)]
                    for part in parts:
                        await bot.api.send_text_message(room.room_id, part)
            else:
                await bot.api.send_text_message(room.room_id, "üö´ Nope. Not your business.")

        elif match.command("HELP"):
            await bot.api.send_text_message(
                room.room_id,
                "**üìö Timecarder Cheat Sheet**\n"
                "`!START` - Clock in.\n"
                "`!PAUSE` - Nap break.\n"
                "`!UNPAUSE` - Back to hustle.\n"
                "`!STOP` - Clock out.\n"
                "`!MEMO` - Add context to your genius.\n"
                "`!VIEW` - Boss-only overview.\n"
                "`!HELP` - Duh."
            )

        else:
            await bot.api.send_text_message(room.room_id, "‚ùå Invalid command. You need `!HELP`. Badly.")

    bot.run()


if __name__ == "__main__":
    main()
